
> Логическая репликация — это репликация изменений на уровне таблиц и строк (INSERT/UPDATE/DELETE), а не на уровне WAL-байтов.

> Это **не замена физической репликации**, а **дополнение** для гибких сценариев.

 Позволяет:
- Реплицировать **только выбранные таблицы**,
- Иметь **разные структуры** на publisher’е и subscriber’е (например, добавить колонки),
- Реплицировать между **разными версиями PostgreSQL** (в пределах совместимости),
- Писать на subscriber’е (в отличие от физической репликации).

## Как это работает

1. **На Publisher’е (источник)**
- Включён `wal_level = logical`.
- WAL содержит **дополнительные данные** для логической декодировки.
- Создаётся **публикация** (`CREATE PUBLICATION`), которая определяет, какие таблицы реплицировать.

2. **Декодирование WAL**
- При подключении subscriber’а запускается **логический WAL Sender**.
- Он **декодирует WAL в логические изменения**:  
    `INSERT INTO public.users VALUES (1, 'Alice');`  
    `UPDATE public.orders SET status = 'shipped' WHERE id = 100;`

3. **На Subscriber’е (приёмник)**
- Создаётся **подписка** (`CREATE SUBSCRIPTION`).
- Запускается **Logical Replication Launcher** → он управляет worker’ами.
- **Apply Worker**:
    - Подключается к publisher’у,
    - Получает поток логических изменений,
    - **Выполняет их как обычные SQL-команды** на локальных таблицах.

4. **Начальная синхронизация**
- При создании подписки автоматически запускаются **Table Sync Worker’ы**.
- Они **копируют все строки** из publisher’а в subscriber через `COPY` или `SELECT`.

| Компонент      | Настройка                                                                            |
| -------------- | ------------------------------------------------------------------------------------ |
| **Publisher**  | `wal_level = logical`                                                                |
|                | Таблицы должны иметь **первичный ключ или REPLICA IDENTITY**                         |
| **Subscriber** | Таблицы должны существовать (или создаются автоматически при `create_slot = true`)   |
|                | Должны быть **совместимы по структуре** (колонки publisher’а ⊆ колонок subscriber’а) |
## Ключевые команды

```sql
-- На publisher’е:
	-- Создать публикацию
	CREATE PUBLICATION mypub FOR TABLE users, orders;
	-- Или для всех таблиц
	CREATE PUBLICATION alltables FOR ALL TABLES;
-- На subscriber’е:
	-- Создать подписку
	CREATE SUBSCRIPTION mysub
	  CONNECTION 'host=publisher dbname=prod user=repuser'
	  PUBLICATION mypub;
	-- Статус
	SELECT * FROM pg_stat_subscription;
```

## Архитектура процессов

|Сервер|Процесс|Роль|
|---|---|---|
|**Publisher**|`WAL Sender (logical)`|Декодирует WAL → отправляет логические изменения|
|**Subscriber**|`Logical Replication Launcher`|Управляет worker’ами|
|**Subscriber**|`Logical Apply Worker`|Применяет изменения к локальным таблицам|
|**Subscriber**|`Table Sync Worker`|Выполняет начальную синхронизацию таблиц|
> **`WAL Receiver` и `Startup`** — они используются только в физической репликации.

## Преимущества логической репликации

| Преимущество                           | Объяснение                                          |
| -------------------------------------- | --------------------------------------------------- |
| **Гибкость выбора таблиц**             | Можно реплицировать только нужные таблицы           |
| **Возможность писать на subscriber’е** | Только в нереплицируемые колонки или таблицы        |
| **Репликация между версиями**          | Например, PG 14 → PG 16 (если нет breaking changes) |
| **Агрегация данных**                   | Несколько publisher’ов → один subscriber            |
| **Миграции и обновления**              | Минимальное время простоя при upgrade               |

---

## Ограничения и нюансы

- Для `UPDATE`/`DELETE` нужно однозначно идентифицировать строку.
```sql
-- Первичный ключ (по умолчанию)
ALTER TABLE users REPLICA IDENTITY DEFAULT;

-- Уникальный индекс
ALTER TABLE users REPLICA IDENTITY USING INDEX users_email_key;

-- Полная строка (тяжело!)
ALTER TABLE users REPLICA IDENTITY FULL;
```

- **DDL не реплицируется**. Нужно применять вручную на subscriber’е.
- Нет репликации системных каталогов
- Конфликты возможны. 
	Если на subscriber’е уже есть строка с таким PK — будет ошибка
- Производительность. 
	Декодирование WAL + выполнение SQL — **дороже**, чем физическая репликация

## Примеры использования

1. **Объединение данных из нескольких источников в одной базе**

Один подписчик — несколько подписок: Один и тот же сервер-подписчик (subscriber) может иметь несколько подписок (subscriptions). Это означает, что он может получать данные из разных публикаций 

Ограничение на одного издателя на подписку: Однако одна подписка (subscription) может быть привязана только к одному издателю (publisher) 

Как достигается «объединение»: Чтобы подписчик получил данные из нескольких источников (разных серверов-издателей), на нём нужно создать отдельную подписку для каждого издателя. Например, вы можете создать subscription_from_server_A и subscription_from_server_B на одном и том же подписчике 

Важное уточнение:
Это не объединение в смысле слияния строк или какого-либо преобразования данных. Логическая репликация просто применяет изменения (INSERT, UPDATE, DELETE) к соответствующим таблицам на подписчике.
- Данные от издателя А будут попадать в таблицы А на подписчике.
- Данные от издателя Б будут попадать в таблицы Б на подписчике.