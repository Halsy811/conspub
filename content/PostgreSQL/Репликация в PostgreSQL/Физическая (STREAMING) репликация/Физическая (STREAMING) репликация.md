
> Физическая репликация — это точное побайтовое копирование WAL-журнала с основного сервера (primary) на резервный (standby) в реальном времени.

Результат: **standby** — это полная копия primary, включая:
- Все данные,
- Все индексы,
- Все системные каталоги,
- Состояние транзакций.
> Это **не логическая репликация** (которая работает на уровне SQL и таблиц).  
> Это **низкоуровневая, блочная репликация**.

### Особенности
- Нельзя писать на standby (Standby — **только для чтения** (кроме временных таблиц))
- Все БД реплицируются. Реплицируется **весь кластер**
- Replication slots

---
## Как это работает (по шагам)

1. **На primary**
- При любой записи (`INSERT`, `UPDATE`, DDL) генерируются **WAL-записи**.
- Эти записи сначала попадают в `wal_buffers` (shared memory), затем на диск (`pg_wal/`).

2. **WAL Sender**
- При подключении standby primary запускает процесс **`WAL Sender`**.
- Он **читает WAL-записи** (из `wal_buffers` или `pg_wal/`) и **отправляет их по сети** на standby.

3. **На standby**
- Запущен в режиме **recovery** (есть файл `standby.signal`).
- Процесс **`WAL Receiver`** принимает WAL и **пишет его в локальный `pg_wal/`**.
- Процесс **`Startup`** **применяет WAL к локальным данным** (heap, индексы и т.д.).

4. **Hot Standby**
- Пока идёт применение WAL, standby может **обслуживать `SELECT`-запросы**.
- Это называется **Hot Standby**.

## Режимы репликации

**Асинхронная (async)**
	- Primary **не ждёт** подтверждения от standby.
	- ✅ Максимальная производительность.
	- ❌ Возможна **потеря данных** при падении primary.

**Синхронная (sync)**
	- Primary **ждёт**, пока standby **запишет WAL на диск** (`synchronous_commit = on` + `synchronous_standby_names`).
	- ✅ **Zero data loss**.
	- ❌ Снижение скорости записи (зависит от задержки сети и диска standby).

> Можно настроить **кворум**: `synchronous_standby_names = '2 (replica1, replica2, replica3)'`.

## Архитектура процессов

|Сервер|Процесс|Роль|
|---|---|---|
|**Primary**|`WAL Sender`|Отправляет WAL по сети|
|**Standby**|`WAL Receiver`|Принимает WAL и пишет в `pg_wal/`|
|**Standby**|`Startup`|Применяет WAL к данным|
|**Оба**|`Checkpointer`|Удаляет старые WAL (с учётом слотов)|

---

## Replication slots

- Предотвращают удаление WAL на primary, пока standby не получит его.
- Защищают от **разрыва репликации** при долгом отключении standby.
- Но могут **заполнить диск** на primary, если standby надолго отключён!
```sql
-- Создать слот
SELECT pg_create_physical_replication_slot('standby1');
```
С слотами:
- Primary **помнит**, до какой позиции WAL уже получил каждый standby.
- Удаляет WAL-файлы **только после того**, как все слоты подтвердили получение.
- Это **предотвращает разрыв репликации** при кратковременных или средних простоях standby.

- Хранит только `restart_lsn` — позицию WAL, до которой standby успел дойти.


---

## ✅ Преимущества физической репликации

- **Полная копия данных** — идеальна для аварийного восстановления.
- **Очень низкая задержка** (миллисекунды).
- **Поддержка Hot Standby** — разгрузка primary для чтения.
- **Надёжность** — основано на WAL, который уже используется для crash recovery.
## ❌ Ограничения

- **Только один уровень репликации** (standby не может быть primary для другого standby, если не использовать cascading).
- **Нет фильтрации** — реплицируется всё.
- **Версии должны совпадать** (minor-версии; major — только при upgrade).
- **Требует много места на диске** (полная копия).

