
# pg_dump

- По умолчанию `pg_dump` создаёт **plain SQL-файл**, который можно восстановить с помощью `psql`
## Backup данных кластера ^psql-pgdump-fullStandby

```sh
### дамп в plain SQL
# pg_dump -U имя_пользователя -h хост -p порт имя_базы > backup.sql
  pg_dump -U postgres -h localhost -p 5432 mydb > mydb_backup.sql

### Дамп в формате custom (двоичный, сжатый)
pg_dump -U postgres -h localhost -F c -b -v -f mydb_backup.custom mydb
#   -F c — custom format
#	-b — включить большие объекты (BLOB)
#	-v — подробный вывод
#	-f — указать файл вывода

### Только структура (без данных)
pg_dump -U postgres --schema-only mydb > schema_only.sql

### Только данные (без DDL)
pg_dump -U postgres --data-only mydb > data_only.sql
```

## Восстановление из SQL-дампа

```sh
# Убедитесь, что база `mydb` уже существует! Если нет — создайте:
createdb -U postgres mydb

### plain SQL-файла
psql -U postgres -h localhost -d mydb < backup.sql

#Или интерактивно:
	psql -U postgres -d mydb
	\i backup.sql
	\q


```

# pg_dumpall

```sh
### Дамп всех баз данных
pg_dumpall -U postgres > all_databases.sql
# Восстановить
createdb -U postgres mydb_restored
psql -U postgres -d mydb_restored < mydb_full.sql
```

## pg_dump кастомные форматы + pg_restore

| Характеристика                              | **`pg_dump` — plain SQL (`-F p`)**      | **`pg_dump` — custom (`-F c`)**            | **`pg_dump` — tar (`-F t`)**         | **`pg_dump` — directory (`-F d`)** | **`pg_restore`**                             |
| ------------------------------------------- | --------------------------------------- | ------------------------------------------ | ------------------------------------ | ---------------------------------- | -------------------------------------------- |
| **Тип файла**                               | Текстовый SQL-скрипт                    | Двоичный архив (один файл)                 | TAR-архив (ограниченная структура)   | Каталог с множеством файлов        | Утилита для восстановления из архивов        |
| **Читаемость**                              | ✅ Человекочитаемый                      | ❌ Нет                                      | ❌ Нет (но можно распаковать как tar) | ❌ Нет (множество двоичных файлов)  | —                                            |
| **Создаётся через**                         | `pg_dump db > file.sql`  <br>или `-F p` | `pg_dump -F c -f file.db db`               | `pg_dump -F t -f file.tar db`        | `pg_dump -F d -f dir/ db`          | —                                            |
| **Восстанавливается через**                 | `psql -f file.sql`                      | `pg_restore -d db file.db`                 | `pg_restore -d db file.tar`          | `pg_restore -d db dir/`            | Только с `-F c`, `-F t`, `-F d`              |
| **Поддержка частичного восстановления**     | ❌ Нет (только ручной фильтр)            | ✅ Да (`-t`, `-n`, `-T`, `-N` и др.)        | ✅ Да (но с ограничениями)            | ✅ Да                               | ✅ Основная функция                           |
| **Параллельное восстановление**             | ❌ Нет                                   | ✅ Да (`-j N`)                              | ❌ Нет                                | ✅ Да (`-j N`)                      | Поддерживает `-j` только для `-F c` и `-F d` |
| **Поддержка больших объектов (BLOB)**       | ✅ Да (через `COPY` или `SELECT`)        | ✅ Полная                                   | ⚠️ Ограничена (до 8 ГБ на объект)    | ✅ Полная                           | ✅ Да                                         |
| **Сжатие**                                  | ❌ Нет (но можно gzip вручную)           | ✅ Встроено (уровень по умолчанию)          | ❌ Нет                                | ✅ Встроено (на уровне файлов)      | —                                            |
| **Макс. размер объекта**                    | Не ограничен                            | Не ограничен                               | **≤ 8 ГБ** на объект                 | Не ограничен                       | —                                            |
| **Использование в продакшене**              | Для простых задач, миграций, отладки    | ✅ Рекомендуется для резервного копирования | Редко (устаревший)                   | ✅ Для очень больших БД             | ✅ Обязателен для работы с архивами           |
| **Просмотр содержимого без восстановления** | Открыть в редакторе                     | `pg_restore -l file.db`                    | `pg_restore -l file.tar`             | `pg_restore -l dir/`               | ✅ Команда `-l` (list)                        |
`pg_restore` - не работает с plain SQL.

### Основные ключи `pg_dump` для частичного резервного копирования
|Ключ|Назначение|Пример|
|---|---|---|
|`-t`, `--table=ИМЯ`|Сохранить **только указанную таблицу** (можно использовать шаблоны: `*`, `?`)|`pg_dump -t users mydb > users.sql`|
|`-T`, `--exclude-table=ИМЯ`|**Исключить** указанную таблицу из дампа|`pg_dump -T logs mydb > no_logs.sql`|
|`-n`, `--schema=ИМЯ`|Сохранить **только объекты из указанной схемы**|`pg_dump -n sales mydb > sales.sql`|
|`-N`, `--exclude-schema=ИМЯ`|**Исключить** всю схему из дампа|`pg_dump -N audit mydb > no_audit.sql`|
|`-s`, `--schema-only`|Сохранить **только структуру** (без данных)|`pg_dump -s mydb > schema.sql`|
|`-a`, `--data-only`|Сохранить **только данные** (без DDL)|`pg_dump -a mydb > data.sql`|
|`--section=SECTION`|Выгрузить только определённую секцию: `pre-data`, `data`, `post-data`|`pg_dump --section=data mydb > data_only.sql`|
|`--inserts`|Генерировать `INSERT` вместо `COPY` (медленнее, но переносимее)|`pg_dump --inserts -t users mydb`|
|`--column-inserts`|Генерировать `INSERT` с указанием колонок (полезно при изменении схемы)|`pg_dump --column-inserts -t users mydb`|

### Основные ключи `pg_restore` для частичного восстановления
| Ключ                              | Назначение                                                               | Пример                                   |
| --------------------------------- | ------------------------------------------------------------------------ | ---------------------------------------- |
| `-t`, `--table=ИМЯ`               | Восстановить **только указанную таблицу**                                | `pg_restore -t users ...`                |
| `-T`, `--exclude-table=ИМЯ`       | **Исключить** указанную таблицу                                          | `pg_restore -T logs ...`                 |
| `-n`, `--schema=ИМЯ`              | Восстановить **только объекты из схемы**                                 | `pg_restore -n public ...`               |
| `-N`, `--exclude-schema=ИМЯ`      | **Исключить** всю схему                                                  | `pg_restore -N audit ...`                |
| `-P`, `--function=ИМЯ(АРГУМЕНТЫ)` | Восстановить **конкретную функцию**                                      | `pg_restore -P "get_user(int)" ...`      |
| `-I`, `--index=ИМЯ`               | Восстановить **только указанный индекс**                                 | `pg_restore -I idx_users_email ...`      |
| `-S`, `--superuser=ИМЯ`           | Указать суперпользователя для DDL-команд (редко используется)            | —                                        |
| `-l`, `--list`                    | **Вывести список всех объектов** в архиве (для анализа)                  | `pg_restore -l backup.db > contents.txt` |
| `--section=SECTION`               | Восстановить только определённую секцию: `pre-data`, `data`, `post-data` | `pg_restore --section=data ...`          |
- Все эти ключи работают **только с архивными форматами** (`-F c`, `-F t`, `-F d`). Для plain SQL (`-F p`) они **не работают** — там только ручной фильтр через `grep`/`sed`.